import { readFile, writeFile } from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const rootDir = path.resolve(__dirname, "..");
const minifigsPath = path.join(rootDir, "data/minifigs.json");
const vehiclesPath = path.join(rootDir, "data/vehicles.json");
const upgradesDataPath = path.join(rootDir, "src/upgrades-data.ts");
const outputPath = path.join(rootDir, "src/ids.ts");

function toPascalCase(label) {
  return label
    .replace(/['â€™]/g, "")
    .replace(/[^A-Za-z0-9]+/g, " ")
    .trim()
    .split(/\s+/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join("");
}

function ensureUniqueName(base, used) {
  let candidate = base.length ? base : "Entry";
  if (/^[0-9]/.test(candidate)) {
    candidate = `N${candidate}`;
  }
  let index = 2;
  while (used.has(candidate)) {
    candidate = `${base || "Entry"}${index++}`;
    if (/^[0-9]/.test(candidate)) {
      candidate = `N${candidate}`;
    }
  }
  used.add(candidate);
  return candidate;
}

function buildEnum(name, entries, formatter) {
  const lines = [`export enum ${name} {`];
  for (const entry of entries) {
    lines.push(`    ${entry.name} = ${formatter(entry.value)},`);
  }
  lines.push("}");
  return lines.join("\n");
}

async function loadUpgradeDefinitions() {
  const source = await readFile(upgradesDataPath, "utf8");
  const match = source.match(/UPGRADE_DEFINITIONS = (\[.*\]) as const;/s);
  if (!match) {
    throw new Error("Unable to parse upgrades data.");
  }
  return JSON.parse(match[1]);
}

async function main() {
  const [minifigsRaw, vehiclesRaw, upgradesRaw] = await Promise.all([
    readFile(minifigsPath, "utf8"),
    readFile(vehiclesPath, "utf8"),
    loadUpgradeDefinitions()
  ]);

  const minifigs = JSON.parse(minifigsRaw);
  const vehicles = JSON.parse(vehiclesRaw);
  const upgrades = upgradesRaw;

  const characterNames = new Set();
  const characterEntries = [{ name: "Unknown", value: 0 }];
  for (const fig of minifigs.sort((a, b) => a.id - b.id)) {
    const base = toPascalCase(fig.name);
    const name = ensureUniqueName(base, characterNames);
    characterEntries.push({ name, value: fig.id });
  }

  const vehicleNames = new Set();
  const vehicleEntries = [];
  for (const vehicle of vehicles.sort((a, b) => a.id - b.id)) {
    const base = toPascalCase(vehicle.name);
    const name = ensureUniqueName(base, vehicleNames);
    vehicleEntries.push({ name, value: vehicle.id });
  }

  const rawUpgradeEntries = [];
  const seenUpgradeIds = new Set();
  for (const entry of upgrades) {
    for (const [group, slots] of Object.entries(entry.slots ?? {})) {
      for (const slot of Array.isArray(slots) ? slots : []) {
        if (!slot || typeof slot.id !== "number" || seenUpgradeIds.has(slot.id)) {
          continue;
        }
        seenUpgradeIds.add(slot.id);
        let label = typeof slot.label === "string" ? slot.label.trim() : "";
        if (!label || label === "-") {
          label =
            typeof slot.digitId === "number"
              ? `digit ${slot.digitId}`
              : `slot ${slot.slot}`;
        }
        const base = toPascalCase(`map${entry.map} ${group} ${label}`);
        rawUpgradeEntries.push({
          value: slot.id,
          base
        });
      }
    }
  }
  rawUpgradeEntries.sort((a, b) => a.value - b.value);
  const upgradeEntries = [];
  const upgradeNames = new Set();
  for (const entry of rawUpgradeEntries) {
    const name = ensureUniqueName(entry.base, upgradeNames);
    upgradeEntries.push({ name, value: entry.value });
  }

  const fileContent = [
    "// AUTO-GENERATED by scripts/generate-ids.mjs. Do not edit manually.",
    buildEnum("CharacterId", characterEntries, (value) => value),
    "",
    buildEnum("VehicleId", vehicleEntries, (value) => value),
    "",
    buildEnum("UpgradeId", upgradeEntries, (value) => value),
    "",
    "export type AnyTagId = CharacterId | VehicleId;"
  ].join("\n");

  await writeFile(outputPath, `${fileContent}\n`, "utf8");
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
